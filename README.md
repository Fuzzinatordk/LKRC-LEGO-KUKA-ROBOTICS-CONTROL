# KUKA 6-DOF Robot Control System

This repository contains a Python-based control system for a KUKA 6-DOF robot, using the **Robotics Toolbox** and **Pybricks**. The system allows for precise robot control, including homing, linear and circular Point-to-Point (PTP) motion, forward and inverse kinematics, and more. The code generates movement instructions and allows control over the robot's joints.

## Requirements

The script is only tested on windows and requires bluetooth functionality to operate

## Dependencies

To run the script, the following dependencies are required:
- **Python 3.8+**
- **numpy**: For matrix calculations and transformations
- **Robotics Toolbox for Python**: For defining robot models and performing kinematic computations
- **spatialmath**: For handling transformation matrices and rotations
- **pybricksdev**: For handling the micropython syntax in the generated file.

Install these dependencies using:
```bash
pip install numpy roboticstoolbox-python spatialmath
```
## Functionality (methods)
- **teach()**
  Visualizes the robot in a matlab plotlib frame, where its possible to set each joint to a value within its limit and return that value as a list and send it to the robot through the FK method
Known issues:

When using the teach method, if using newer versions of matplotlib, an error can occur where the function is given more parameters than needed.
This can be fixed by navigating to Pyplot.py and go to line 575 and replace the line of code with the following:

                slider = Slider(
                  ax, "q" + str(j), qlim[0, j], qlim[1, j], valinit=np.degrees(q[j]), valfmt="%.1fÂ°"
- **linearPTP([x,y,z]**
  Moves the robot a given direction (x,y,z) in milimeters, the method checks if the value chosen is within limits of inverse-kinematics and stores the point in a list and can be executed with linearRun
- **linearRun()**
  Runs the list generated by linearPTP <br>
  Example:
  ````bash
  run = robotMovement()
  run.linearPTP([50,0,0])
  run.linearPTP([0,50,0])
  run.linearRun()
  ````
- **FK_solution([angles],'type')** <br>
  Takes a joint configuration in either degrees or radians, the default type is degrees, but if the unit is in radians type can be set to 'rad' <br>
  And then if the joints are within the limits, it returns the end-effector transformation matrix given from base to end-effector.
- **homing()** <br>
  Homes the robot to its initial configuration
- **DH()** <br>
  Returns the DH parameters.
- **getJacob()** <br>
  Returns the jacobian of the robot given the current configuration q0.
- **FK([pose],'type',plot=False,PTP=False)** <br>
  FK(forward kinematics) calculates the end-effector transformation matrix from base to end, and returns the matrix if a solution was found. <br>
  First argument is a pose, given as a list with the length 6. Secondly type is the unit of the pose (rad/deg), default is deg.<br>
  Thirdly you can plot the pose from q0 to the given pose if a solution is found by setting it to True.<br>
  Lastly PTP shows how the joints degree change over time during the movement, and the plot can be shown if you parse the argument as True.
- **IK([pose],'type',plot=False,PTP=False)** <br>
  IK(inverse kinematics) Takes the given end-effector position and orientation [x,y,z,theta_x,theta_y,theta_z] and tries to solve for a joint configuration, respecting the limits and then it sends it to the robot 
  to run it. <br>
  Thirdly you can plot the pose from q0 to the given pose if a solution is found by setting it to True.<br>
  Lastly PTP shows how the joints degree change over time during the movement, and the plot can be shown if you parse the argument as True.
- **randomPose(plot=False,PTP=False)** <br>
  Generates a random pose within the limits and can be visualized by the plot argument or/and PTP by setting its corresponding argument to True <br>
  Afterwards the instruction is sent to the robot and runs it.
- **limitsDeg()** <br>
  Returns the joint limits in degrees
- **limitsRad()** <br>
  Returns the joint limits in radians
- **PTPplot([angles])** <br>
  Shows the joint movement overtime from q0 to angles if its within the limits <br>
  *SHOULD BE IN RADIANS
- **posePlot([angles])** <br>
  Shows the plot going from q0 to the given angles in a matplotlib frame
  *SHOULD BE IN RADIANS
  
  
